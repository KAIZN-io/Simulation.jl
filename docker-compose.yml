version: "2.1"

services:

  db:
    # Define the environment variables for this container
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    # A health check is used to determine if the container is ready for the other services
    healthcheck:
      # the command executed to test the health of the container
      test: ["CMD", "pg_isready", "-U", "${DB_USER}", "-d", "${DB_NAME}"]
      # the time between the checks
      interval: 15s
      # the timeout after which a check will be considered failed
      timeout: 3s
      # the amount of retries until the container will be marked unhelthy
      retries: 8
    # the image to use for this service
    image: postgres:11.2-alpine
    # the networks this service is connected to. Networks are defined at the bottom of the file
    networks:
      - db
    # Portmapping for accessing this service from your host machine. <host-port>:<container-port>
    ports:
      - "5433:5432"
    # Defining volumes to persist specific data from within the container
    # This way data will remain throughout restarts of the service
    volumes:
      - userDb:/var/lib/postgresql/data/

  server:
    # The command is appended to the entrypoint specified in the Dockerfile
    command: ["-m", "server"]
    # Defining which other services are needed for this service to work
    # This will automatically start all dependencies when running `dc up web`
    depends_on:
      db:
        condition: service_healthy
      messageBroker:
        condition: service_healthy
      simulationWorker:
        condition: service_started
      dbWorker:
        condition: service_started
    environment:
      - DEBUG
      - FLASK_ENV
      - DB_NAME
      - DB_USER
      - DB_PASSWORD
      - QUEUE_SCHEDULED_SIMULATIONS
    image: janpiotraschke/projectq:0.3.2
    networks:
      - db
      - messageBroker
    ports:
      - "8080:5000"
    # Mount the project code into the container, so the container can run it. <host-path>:<container-path>
    volumes:
      - ./projectQ/:/ProjektQ/

  dbWorker:
    command: ["-u", "-m", "dbWorker"]
    depends_on:
      db:
        condition: service_healthy
      messageBroker:
        condition: service_healthy
    environment:
      - DEBUG
      - DB_NAME
      - DB_USER
      - DB_PASSWORD
      - QUEUE_SIMULATION_RESULTS
    image: janpiotraschke/projectq:0.3.2
    networks:
      - db
      - messageBroker
    volumes:
      - ./projectQ/:/ProjektQ/

  simulationWorker:
    command: ["-u", "-m", "simulationWorker"]
    depends_on:
      messageBroker:
        condition: service_healthy
    environment:
      - DEBUG
      - QUEUE_SCHEDULED_SIMULATIONS
      - QUEUE_SIMULATION_RESULTS
    image: janpiotraschke/projectq:0.3.2
    networks:
      - messageBroker
    volumes:
      - ./projectQ/:/ProjektQ/

  messageBroker:
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 15s
      timeout: 3s
      retries: 8
    image: rabbitmq:3.7.11-rc.2-alpine
    networks:
      - messageBroker

# Define named volumes for use in the service definitions
volumes:
  userDb:

# Define the networks, so we can assign services to them
networks:
  # The network used for communicating with the database
  db:
  # Network used for communication with the message broker
  messageBroker:

