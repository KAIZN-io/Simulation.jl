version: "2.1"

services:

  db:
    image: postgres
    volumes:
      - user-db:/var/lib/postgresql/data/

    # environment variables which will be accessible in the running container
    # legt Databank simulation_results an
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}

    # this defines how this container will be rated as "healthy"
    # definiert, wann die Datenbank hochgefahren ist
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "${DB_USER}", "-d", "${DB_NAME}"]
      # the time between the checks
      interval: 15s
      # the timeout after which a check will be considered failed
      timeout: 3s
      # the amount of retries until the container will be marked unhelthy
      retries: 8

    # erstellt Portmapping; wenn Rechner angesprochen wird, reicht er es ihn den
    # Container weiter
    # <Port am PC>:<Port am Container>
    ports:
      - "5433:5432"

    networks:
      - db

  web:
    image: janpiotraschke/projectq:0.2.2

    # was sdtm braucht: ein hochgefahrene Datenbank (in diesem Beispiel)
    # wie Verzweigungen zwischen Programmen auslegen
    depends_on:
      # the status of the api-db needs to be healthy (see above)
      db:
        condition: service_healthy
      taskQueue:
        condition: service_healthy
      simulationWorker:
        condition: service_started
      dbWorker:
        condition: service_started

    ports:
      - "8080:5000"

    environment:
      - DEBUG
      - FLASK_DEBUG=${DEBUG}
      - FLASK_ENV
      - FLASK_APP
      - DB_NAME
      - DB_USER
      - DB_PASSWORD
      - QUEUE_SCHEDULED_SIMULATIONS

    # for development we mount the api-server-code into the container,
    # this way changes made to the code are directly synced with the container
    volumes:
      # in welchen Pfad ich mich befinde : WORKDIR von Dockerfile
      - ./projectQ/:/ProjektQ/

    # Befehl der and ENTRYPOINT aus dem Image dran gehangen wird.
    command: ["-m", "flask", "run", "--host=0.0.0.0"]

    networks:
      - db
      - message

  dbWorker:
    image: janpiotraschke/projectq:0.2.2
    depends_on:
      db:
        condition: service_healthy
      taskQueue:
        condition: service_healthy
    environment:
      - DEBUG
      - DB_NAME
      - DB_USER
      - DB_PASSWORD
      - QUEUE_SIMULATION_RESULTS
    volumes:
      - ./projectQ/:/ProjektQ/
    command: ["-u", "-m", "dbWorker"]
    networks:
      - db
      - message

  simulationWorker:
    image: janpiotraschke/projectq:0.2.2
    depends_on:
      taskQueue:
        condition: service_healthy
    environment:
      - DEBUG
      - QUEUE_SCHEDULED_SIMULATIONS
      - QUEUE_SIMULATION_RESULTS
    volumes:
      - ./projectQ/:/ProjektQ/
    working_dir: /ProjektQ
    command: ["-u", "-m", "simulationWorker"]
    networks:
      - message

  taskQueue:
    image: rabbitmq:3.7.11-rc.2-alpine
    healthcheck:
      test: ["CMD", "rabbitmqctl", "status"]
      interval: 15s
      timeout: 3s
      retries: 8
    networks:
      - message

# Eigenart von docker-compose file; hier nochmal die verwendeten volumes angeben
volumes:
  user-db:

networks:
  db:
  message:

